<?xml version="1.0" ?>
<codebase name="codebase2xml" version="1.0" timestamp="2025-06-30T23:41:54.127376">
  <metadata>
    <description>Archived codebase: codebase2xml</description>
    <source_path>/Users/geoanima/GitHub/codebase2xml</source_path>
    <statistics total_files="8" total_directories="2" total_size="34017"/>
    <file_types>
      <type name="dependencies" count="1"/>
      <type name="license" count="1"/>
      <type name="markdown" count="1"/>
      <type name="python" count="4"/>
      <type name="setup" count="1"/>
    </file_types>
    <languages>
      <language>python</language>
    </languages>
  </metadata>
  <structure>
    <directory name="/" path="/Users/geoanima/GitHub/codebase2xml">
      <directory name="src" path="/Users/geoanima/GitHub/codebase2xml/src">
        <directory name="codebase2xml" path="/Users/geoanima/GitHub/codebase2xml/src/codebase2xml">
          <file name="__init__.py" type="python"/>
          <file name="__main__.py" type="python"/>
          <file name="cli.py" type="python"/>
          <file name="core.py" type="python"/>
        </directory>
      </directory>
      <file name="LICENSE" type="license"/>
      <file name="README.md" type="markdown"/>
      <file name="requirements.txt" type="dependencies"/>
      <file name="setup.py" type="setup"/>
    </directory>
  </structure>
  <files>
    <file name="LICENSE" path="/Users/geoanima/GitHub/codebase2xml/LICENSE" type="license" size="1078" modified="2025-06-30T18:42:53.145711" created="2025-06-30T18:42:53.166526" permissions="644" lines="21">
      <content>MIT License
Copyright (c) 2025 Generated by Geo Anima
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</content>
    </file>
    <file name="requirements.txt" path="/Users/geoanima/GitHub/codebase2xml/requirements.txt" type="dependencies" size="226" modified="2025-06-30T18:08:10.094654" created="2025-06-30T18:44:42.375226" permissions="644" lines="6">
      <content># codebase2xml requirements
# No external dependencies required - uses Python standard library only
# Python 3.8+ is required for:
# - pathlib.Path advanced methods
# - typing annotations
# - xml.etree.ElementTree enhancements</content>
    </file>
    <file name="README.md" path="/Users/geoanima/GitHub/codebase2xml/README.md" type="markdown" size="7794" modified="2025-06-30T22:01:05.787894" created="2025-06-30T23:25:57.314827" permissions="644" lines="292">
      <content># codebase2xml
Transform any codebase directory into a comprehensive XML archive that preserves structure, content, and metadata.
## Overview
`codebase2xml` is a Python utility that creates lossless XML archives of codebases. It captures the complete directory structure, file contents, metadata, and provides intelligent file type detection. Perfect for:
- **AI &amp; LLM workflows**
- **Codebase documentation and archival**
- **Project structure analysis** 
- **Backup and migration purposes**
- **Code review and analysis workflows**
- **Legal compliance and audit trails**
## Features
### üèóÔ∏è Complete Structure Preservation
- Recursive directory tree capture
- File and folder hierarchy maintenance
- Symbolic link detection and handling
### üìÑ Intelligent Content Handling
- Automatic text vs binary file detection
- Configurable file size limits
- Encoding-aware text processing
- Binary file metadata without content bloat
### üîç Advanced File Type Detection
- 50+ programming languages supported
- Configuration files (JSON, YAML, TOML, etc.)
- Documentation formats (Markdown, RST, etc.)
- Web technologies (HTML, CSS, JS frameworks)
- Data formats (CSV, Excel, databases)
- Media files (images, audio, video)
- Special files (README, LICENSE, Dockerfile, etc.)
### ‚öôÔ∏è Flexible Configuration
- Customizable ignore patterns
- File size limits
- Binary content inclusion options
- Quiet mode for scripting
### üìä Rich Metadata
- File statistics (size, dates, permissions)
- Language distribution analysis
- File type categorization
- Project-level metrics
## Installation
### From Source
```bash
git clone &lt;repository-url&gt;
cd codebase2xml
pip install -e .
```
### Requirements
- Python 3.8 or higher
- No external dependencies (uses only Python standard library)
## Usage
### Command Line Interface
#### Basic Usage
```bash
# Archive current directory
codebase2xml .
# Archive specific directory
codebase2xml /path/to/project
# Specify output location
codebase2xml /path/to/project --output /path/to/archive.xml
```
#### Advanced Options
```bash
# Custom ignore patterns
codebase2xml . --ignore "*.log,temp,node_modules,*.pyc"
# Set maximum file size (10MB default)
codebase2xml . --max-size 5242880  # 5MB
# Include binary file content (not recommended for large projects)
codebase2xml . --include-binary
# Quiet mode (only outputs result path)
codebase2xml . --quiet
```
### Python API
```python
from pathlib import Path
from codebase2xml import CodebaseArchiver
# Create archiver with custom settings
archiver = CodebaseArchiver(
    ignore_patterns=['*.log', 'node_modules', '.git'],
    max_file_size=10 * 1024 * 1024,  # 10MB
    include_binary=False
)
# Archive a codebase
codebase_path = Path('/path/to/project')
output_path = archiver.archive_codebase(codebase_path)
print(f"Archive created: {output_path}")
```
## Output Format
The generated XML follows this structure:
```xml
&lt;?xml version="1.0" ?&gt;
&lt;codebase name="project-name" version="1.0" timestamp="2024-01-01T12:00:00"&gt;
  &lt;!-- Project metadata --&gt;
  &lt;metadata&gt;
    &lt;description&gt;Archived codebase: project-name&lt;/description&gt;
    &lt;source_path&gt;/path/to/project&lt;/source_path&gt;
    &lt;statistics total_files="150" total_directories="25" total_size="2048576"/&gt;
    &lt;file_types&gt;
      &lt;type name="python" count="45"/&gt;
      &lt;type name="javascript" count="23"/&gt;
      &lt;type name="markdown" count="8"/&gt;
      &lt;!-- ... more types --&gt;
    &lt;/file_types&gt;
    &lt;languages&gt;
      &lt;language&gt;python&lt;/language&gt;
      &lt;language&gt;javascript&lt;/language&gt;
      &lt;!-- ... more languages --&gt;
    &lt;/languages&gt;
  &lt;/metadata&gt;
  &lt;!-- Directory structure tree --&gt;
  &lt;structure&gt;
    &lt;directory name="/" path="/path/to/project"&gt;
      &lt;file name="README.md" type="markdown"/&gt;
      &lt;file name="setup.py" type="setup"/&gt;
      &lt;directory name="src" path="/path/to/project/src"&gt;
        &lt;!-- ... nested structure --&gt;
      &lt;/directory&gt;
    &lt;/directory&gt;
  &lt;/structure&gt;
  &lt;!-- File contents and metadata --&gt;
  &lt;files&gt;
    &lt;file name="README.md" path="/path/to/project/README.md" 
          type="markdown" size="1024" lines="45" 
          modified="2024-01-01T12:00:00" permissions="644"&gt;
      &lt;content&gt;&lt;![CDATA[
        # Project Name
        Project description...
      ]]&gt;&lt;/content&gt;
    &lt;/file&gt;
    &lt;!-- ... more files --&gt;
  &lt;/files&gt;
&lt;/codebase&gt;
```
## File Type Detection
The system automatically detects and categorizes files:
### Programming Languages
Python, JavaScript, TypeScript, Java, C/C++, C#, PHP, Ruby, Go, Rust, Swift, Kotlin, Scala, R, MATLAB, Shell scripts, PowerShell, SQL, Perl, Lua, Dart, Elm, Elixir, Clojure, Haskell, OCaml, F#, Visual Basic
### Configuration Files
JSON, YAML, TOML, INI, .env files, Docker configs, Git configs, Editor configs
### Documentation
Markdown, reStructuredText, plain text, Word docs, PDFs, LaTeX, Org-mode
### Web Technologies
HTML, CSS, SCSS/Sass, Less, Vue, JSX, TSX, Svelte
### Data Formats
CSV, TSV, Excel, SQLite, Parquet, Avro
### Special Files
README, LICENSE, CHANGELOG, Makefile, Dockerfile, package.json, requirements.txt, setup.py, and many more
## Command Line Options
| Option | Short | Description | Default |
|--------|-------|-------------|---------|
| `--output` | `-o` | Output XML file path | Auto-generated |
| `--ignore` | `-i` | Comma-separated ignore patterns | Common patterns |
| `--max-size` | `-s` | Maximum file size for content (bytes) | 10MB |
| `--include-binary` | `-b` | Include binary file content | False |
| `--quiet` | `-q` | Suppress progress output | False |
| `--version` | `-v` | Show version information | - |
## Default Ignore Patterns
The following patterns are ignored by default:
- `*.pyc`, `__pycache__` (Python cache)
- `.git`, `.svn`, `.hg` (Version control)
- `node_modules` (Node.js dependencies)
- `.DS_Store` (macOS metadata)
- `*.log`, `*.tmp` (Temporary files)
- `.venv`, `venv` (Virtual environments)
- `.env` (Environment files)
- `.idea`, `.vscode` (IDE files)
## Examples
### Archive a Python Project
```bash
codebase2xml my-python-project --ignore "*.pyc,__pycache__,.pytest_cache,dist,build"
```
### Archive a Node.js Project
```bash
codebase2xml my-node-app --ignore "node_modules,dist,build,.next,.nuxt"
```
### Archive with Custom Settings
```bash
codebase2xml . \
  --output detailed_archive.xml \
  --max-size 20971520 \
  --ignore "*.log,temp,cache" \
  --include-binary
```
### Scripting Integration
```bash
# Generate archive and capture output path
ARCHIVE_PATH=$(codebase2xml . --quiet)
echo "Archive created at: $ARCHIVE_PATH"
# Upload to cloud storage, send via email, etc.
aws s3 cp "$ARCHIVE_PATH" s3://my-bucket/archives/
```
## Use Cases
### üìö Documentation
Create comprehensive project documentation that includes both structure and content for onboarding or handoffs.
### üîí Compliance
Generate audit trails and compliance documentation for regulated industries.
### üèóÔ∏è Migration
Prepare codebases for migration between systems while preserving complete context.
### üîç Analysis
Enable detailed code analysis, dependency tracking, and architectural reviews.
### üíæ Backup
Create structured backups that are more useful than simple file copies.
### ü§ñ AI/ML Training
Prepare codebases for AI model training with structured, labeled data.
## Technical Details
### Performance
- Handles large codebases efficiently
- Memory-conscious streaming for large files
- Parallel processing where possible
- Configurable limits to prevent resource exhaustion
### Compatibility
- Cross-platform (Windows, macOS, Linux)
- Python 3.8+ support
- No external dependencies
- Unicode and encoding-aware
### Security
- No network operations
- Read-only filesystem access
- Configurable file size limits
- Safe handling of binary content</content>
    </file>
    <file name="setup.py" path="/Users/geoanima/GitHub/codebase2xml/setup.py" type="setup" size="1974" modified="2025-06-30T21:52:22.990257" created="2025-06-30T21:52:22.990257" permissions="644" lines="58">
      <content>"""Setup configuration for codebase2xml."""
from setuptools import setup, find_packages
from pathlib import Path
# Read README for long description
readme_path = Path(__file__).parent / "README.md"
if readme_path.exists():
    with open(readme_path, "r", encoding="utf-8") as fh:
        long_description = fh.read()
else:
    long_description = "Transform any codebase directory into a comprehensive XML archive"
setup(
    name="codebase2xml",
    version="1.0.0",
    author="Geo Anima",
    author_email="",
    description="Transform any codebase directory into a comprehensive XML archive",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="",
    package_dir={"": "src"},
    packages=find_packages(where="src"),
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "Topic :: Software Development :: Documentation",
        "Topic :: Text Processing :: Markup :: XML",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Programming Language :: Python :: 3.13",
        "Operating System :: OS Independent",
    ],
    python_requires="&gt;=3.8",
    install_requires=[
        # No external dependencies - uses only Python standard library
    ],
    entry_points={
        "console_scripts": [
            "codebase2xml=codebase2xml.cli:main",
        ],
    },
    keywords=[
        "codebase", "archive", "xml", "backup", "documentation", 
        "code-analysis", "project-structure", "file-tree"
    ],
    project_urls={
        "Bug Reports": "",
        "Source": "",
    },
)</content>
    </file>
    <file name="__init__.py" path="/Users/geoanima/GitHub/codebase2xml/src/codebase2xml/__init__.py" type="python" size="225" modified="2025-06-30T21:53:28.882626" created="2025-06-30T22:12:32.894936" permissions="644" lines="5">
      <content>"""codebase2xml - Transform any codebase into a comprehensive XML archive."""
__version__ = "1.0.0"
__author__ = "Geo Anima"
__description__ = "Losslessly archive any codebase directory structure and content into XML format"</content>
    </file>
    <file name="core.py" path="/Users/geoanima/GitHub/codebase2xml/src/codebase2xml/core.py" type="python" size="17472" modified="2025-06-30T18:09:29.957473" created="2025-06-30T18:45:20.941695" permissions="644" lines="402">
      <content>"""Core XML generation functionality for codebase archiving."""
import os
import re
import mimetypes
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Set, Tuple
import xml.etree.ElementTree as ET
from xml.dom import minidom
class FileTypeDetector:
    """Detects file types and categorizes them."""
    PROGRAMMING_EXTENSIONS = {
        '.py': 'python', '.js': 'javascript', '.ts': 'typescript', '.java': 'java',
        '.cpp': 'cpp', '.c': 'c', '.h': 'header', '.hpp': 'header',
        '.cs': 'csharp', '.php': 'php', '.rb': 'ruby', '.go': 'go',
        '.rs': 'rust', '.swift': 'swift', '.kt': 'kotlin', '.scala': 'scala',
        '.r': 'r', '.m': 'matlab', '.sh': 'shell', '.bash': 'shell',
        '.zsh': 'shell', '.fish': 'shell', '.ps1': 'powershell',
        '.sql': 'sql', '.pl': 'perl', '.lua': 'lua', '.dart': 'dart',
        '.elm': 'elm', '.ex': 'elixir', '.exs': 'elixir', '.clj': 'clojure',
        '.hs': 'haskell', '.ml': 'ocaml', '.fs': 'fsharp', '.vb': 'vbasic'
    }
    CONFIG_EXTENSIONS = {
        '.json': 'json', '.yaml': 'yaml', '.yml': 'yaml', '.toml': 'toml',
        '.ini': 'ini', '.cfg': 'config', '.conf': 'config', '.properties': 'properties',
        '.env': 'environment', '.dockerignore': 'docker', '.gitignore': 'git',
        '.gitattributes': 'git', '.editorconfig': 'editor'
    }
    DOCUMENTATION_EXTENSIONS = {
        '.md': 'markdown', '.rst': 'restructuredtext', '.txt': 'text',
        '.doc': 'word', '.docx': 'word', '.pdf': 'pdf', '.rtf': 'rtf',
        '.tex': 'latex', '.org': 'org-mode', '.wiki': 'wiki'
    }
    WEB_EXTENSIONS = {
        '.html': 'html', '.htm': 'html', '.xml': 'xml', '.xhtml': 'xhtml',
        '.css': 'css', '.scss': 'scss', '.sass': 'sass', '.less': 'less',
        '.vue': 'vue', '.jsx': 'jsx', '.tsx': 'tsx', '.svelte': 'svelte'
    }
    DATA_EXTENSIONS = {
        '.csv': 'csv', '.tsv': 'tsv', '.xlsx': 'excel', '.xls': 'excel',
        '.ods': 'spreadsheet', '.sqlite': 'sqlite', '.db': 'database',
        '.parquet': 'parquet', '.arrow': 'arrow', '.avro': 'avro'
    }
    MEDIA_EXTENSIONS = {
        '.png': 'image', '.jpg': 'image', '.jpeg': 'image', '.gif': 'image',
        '.svg': 'vector', '.ico': 'icon', '.bmp': 'image', '.tiff': 'image',
        '.mp4': 'video', '.avi': 'video', '.mov': 'video', '.wmv': 'video',
        '.mp3': 'audio', '.wav': 'audio', '.flac': 'audio', '.ogg': 'audio'
    }
    SPECIAL_FILES = {
        'README': 'documentation', 'LICENSE': 'license', 'CHANGELOG': 'documentation',
        'CONTRIBUTING': 'documentation', 'INSTALL': 'documentation', 'MANIFEST': 'manifest',
        'Makefile': 'build', 'makefile': 'build', 'CMakeLists.txt': 'build',
        'Dockerfile': 'docker', 'docker-compose.yml': 'docker', 'docker-compose.yaml': 'docker',
        'requirements.txt': 'dependencies', 'package.json': 'dependencies', 
        'setup.py': 'setup', 'setup.cfg': 'setup', 'pyproject.toml': 'setup',
        'Cargo.toml': 'dependencies', 'pom.xml': 'dependencies', 'build.gradle': 'build',
        'package-lock.json': 'lockfile', 'yarn.lock': 'lockfile', 'Pipfile.lock': 'lockfile'
    }
    def detect_type(self, file_path: Path) -&gt; str:
        """Detect the type of a file based on its name and extension."""
        filename = file_path.name
        suffix = file_path.suffix.lower()
        # Check special files first
        if filename in self.SPECIAL_FILES:
            return self.SPECIAL_FILES[filename]
        # Check by extension
        if suffix in self.PROGRAMMING_EXTENSIONS:
            return self.PROGRAMMING_EXTENSIONS[suffix]
        elif suffix in self.CONFIG_EXTENSIONS:
            return self.CONFIG_EXTENSIONS[suffix]
        elif suffix in self.DOCUMENTATION_EXTENSIONS:
            return self.DOCUMENTATION_EXTENSIONS[suffix]
        elif suffix in self.WEB_EXTENSIONS:
            return self.WEB_EXTENSIONS[suffix]
        elif suffix in self.DATA_EXTENSIONS:
            return self.DATA_EXTENSIONS[suffix]
        elif suffix in self.MEDIA_EXTENSIONS:
            return self.MEDIA_EXTENSIONS[suffix]
        # Try to use mimetypes as fallback
        mime_type, _ = mimetypes.guess_type(str(file_path))
        if mime_type:
            if mime_type.startswith('text/'):
                return 'text'
            elif mime_type.startswith('image/'):
                return 'image'
            elif mime_type.startswith('audio/'):
                return 'audio'
            elif mime_type.startswith('video/'):
                return 'video'
            elif mime_type.startswith('application/'):
                return 'binary'
        # Default fallback
        if suffix:
            return f'unknown{suffix}'
        return 'unknown'
class CodebaseArchiver:
    """Main class for archiving codebases to XML."""
    def __init__(self, 
                 ignore_patterns: Optional[List[str]] = None,
                 max_file_size: int = 10 * 1024 * 1024,  # 10MB
                 include_binary: bool = False):
        """
        Initialize the archiver.
        Args:
            ignore_patterns: List of glob patterns to ignore
            max_file_size: Maximum file size to include content for (bytes)
            include_binary: Whether to include binary file content
        """
        self.file_detector = FileTypeDetector()
        self.ignore_patterns = ignore_patterns or [
            '*.pyc', '__pycache__', '.git', '.svn', '.hg', 
            'node_modules', '.DS_Store', '*.log', '*.tmp',
            '.venv', 'venv', '.env', '.idea', '.vscode'
        ]
        self.max_file_size = max_file_size
        self.include_binary = include_binary
    def _should_ignore(self, path: Path) -&gt; bool:
        """Check if a path should be ignored based on patterns."""
        path_str = str(path)
        name = path.name
        for pattern in self.ignore_patterns:
            if pattern in path_str or self._match_pattern(name, pattern):
                return True
        return False
    def _match_pattern(self, name: str, pattern: str) -&gt; bool:
        """Simple glob pattern matching."""
        if '*' in pattern:
            # Convert glob pattern to regex
            regex_pattern = pattern.replace('*', '.*').replace('?', '.')
            return re.match(f'^{regex_pattern}$', name) is not None
        return name == pattern
    def _is_text_file(self, file_path: Path) -&gt; bool:
        """Determine if a file is text-based and should have content included."""
        if not self.include_binary:
            file_type = self.file_detector.detect_type(file_path)
            binary_types = {'image', 'audio', 'video', 'binary', 'excel', 'sqlite', 'database'}
            if any(bt in file_type for bt in binary_types):
                return False
        try:
            # Try to read a small portion as text
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                f.read(1024)
            return True
        except (UnicodeDecodeError, PermissionError, OSError):
            return False
    def _get_file_stats(self, file_path: Path) -&gt; Dict:
        """Get file statistics and metadata."""
        try:
            stat = file_path.stat()
            return {
                'size': stat.st_size,
                'modified': datetime.fromtimestamp(stat.st_mtime).isoformat(),
                'created': datetime.fromtimestamp(stat.st_ctime).isoformat(),
                'permissions': oct(stat.st_mode)[-3:]
            }
        except (OSError, PermissionError):
            return {}
    def _count_lines(self, content: str) -&gt; int:
        """Count the number of lines in content."""
        return len(content.splitlines()) if content else 0
    def _clean_xml_content(self, content: str) -&gt; str:
        """Clean content to be XML-safe by removing invalid characters."""
        if not content:
            return content
        # Remove characters that are invalid in XML 1.0
        # Valid: #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
        valid_chars = []
        for char in content:
            code = ord(char)
            if (code == 0x09 or code == 0x0A or code == 0x0D or 
                (0x20 &lt;= code &lt;= 0xD7FF) or 
                (0xE000 &lt;= code &lt;= 0xFFFD) or 
                (0x10000 &lt;= code &lt;= 0x10FFFF)):
                valid_chars.append(char)
            else:
                # Replace invalid characters with placeholder
                valid_chars.append('ÔøΩ')
        return ''.join(valid_chars)
    def _extract_metadata(self, codebase_path: Path) -&gt; Dict:
        """Extract metadata about the codebase."""
        metadata = {
            'name': codebase_path.name,
            'path': str(codebase_path.absolute()),
            'timestamp': datetime.now().isoformat(),
            'total_files': 0,
            'total_directories': 0,
            'total_size': 0,
            'file_types': {},
            'languages': set()
        }
        for item in codebase_path.rglob('*'):
            if self._should_ignore(item):
                continue
            if item.is_file():
                metadata['total_files'] += 1
                try:
                    size = item.stat().st_size
                    metadata['total_size'] += size
                    file_type = self.file_detector.detect_type(item)
                    metadata['file_types'][file_type] = metadata['file_types'].get(file_type, 0) + 1
                    # Track programming languages
                    if file_type in self.file_detector.PROGRAMMING_EXTENSIONS.values():
                        metadata['languages'].add(file_type)
                except (OSError, PermissionError):
                    pass
            elif item.is_dir():
                metadata['total_directories'] += 1
        metadata['languages'] = list(metadata['languages'])
        return metadata
    def _build_structure_tree(self, root_path: Path, current_path: Path) -&gt; ET.Element:
        """Build the directory structure tree recursively."""
        rel_path = current_path.relative_to(root_path)
        if current_path.is_file():
            file_elem = ET.Element('file')
            file_elem.set('name', current_path.name)
            file_elem.set('type', self.file_detector.detect_type(current_path))
            return file_elem
        else:
            dir_elem = ET.Element('directory')
            dir_elem.set('name', current_path.name if current_path != root_path else '/')
            dir_elem.set('path', str(current_path))
            # Add children
            try:
                children = sorted(current_path.iterdir(), key=lambda x: (x.is_file(), x.name.lower()))
                for child in children:
                    if not self._should_ignore(child):
                        child_elem = self._build_structure_tree(root_path, child)
                        dir_elem.append(child_elem)
            except (PermissionError, OSError):
                pass
            return dir_elem
    def archive_codebase(self, codebase_path: Path, output_path: Optional[Path] = None) -&gt; Path:
        """
        Archive a codebase directory to XML format.
        Args:
            codebase_path: Path to the codebase directory
            output_path: Optional output path for the XML file
        Returns:
            Path to the generated XML file
        """
        if not codebase_path.exists():
            raise FileNotFoundError(f"Codebase path does not exist: {codebase_path}")
        if not codebase_path.is_dir():
            raise NotADirectoryError(f"Path is not a directory: {codebase_path}")
        # Generate output path if not provided
        if output_path is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_path = codebase_path / f"{codebase_path.name}_archive_{timestamp}.xml"
        # Extract metadata
        metadata = self._extract_metadata(codebase_path)
        # Create root XML element
        root = ET.Element('codebase')
        root.set('name', metadata['name'])
        root.set('version', '1.0')
        root.set('timestamp', metadata['timestamp'])
        # Add metadata section
        meta_elem = ET.SubElement(root, 'metadata')
        desc_elem = ET.SubElement(meta_elem, 'description')
        desc_elem.text = f"Archived codebase: {metadata['name']}"
        path_elem = ET.SubElement(meta_elem, 'source_path')
        path_elem.text = metadata['path']
        stats_elem = ET.SubElement(meta_elem, 'statistics')
        stats_elem.set('total_files', str(metadata['total_files']))
        stats_elem.set('total_directories', str(metadata['total_directories']))
        stats_elem.set('total_size', str(metadata['total_size']))
        # Add file types
        if metadata['file_types']:
            types_elem = ET.SubElement(meta_elem, 'file_types')
            for file_type, count in sorted(metadata['file_types'].items()):
                type_elem = ET.SubElement(types_elem, 'type')
                type_elem.set('name', file_type)
                type_elem.set('count', str(count))
        # Add languages
        if metadata['languages']:
            langs_elem = ET.SubElement(meta_elem, 'languages')
            for lang in sorted(metadata['languages']):
                lang_elem = ET.SubElement(langs_elem, 'language')
                lang_elem.text = lang
        # Add structure section
        structure_elem = ET.SubElement(root, 'structure')
        structure_tree = self._build_structure_tree(codebase_path, codebase_path)
        structure_elem.append(structure_tree)
        # Add files section with content
        files_elem = ET.SubElement(root, 'files')
        for file_path in codebase_path.rglob('*'):
            if file_path.is_file() and not self._should_ignore(file_path):
                try:
                    file_elem = ET.SubElement(files_elem, 'file')
                    file_elem.set('name', file_path.name)
                    file_elem.set('path', str(file_path))
                    file_elem.set('type', self.file_detector.detect_type(file_path))
                    # Add file stats
                    stats = self._get_file_stats(file_path)
                    for key, value in stats.items():
                        file_elem.set(key, str(value))
                    # Add content if it's a text file and not too large
                    if (file_path.stat().st_size &lt;= self.max_file_size and 
                        self._is_text_file(file_path)):
                        try:
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                            if content.strip():  # Only add non-empty content
                                file_elem.set('lines', str(self._count_lines(content)))
                                content_elem = ET.SubElement(file_elem, 'content')
                                # Clean content for XML - remove invalid XML characters
                                clean_content = self._clean_xml_content(content)
                                content_elem.text = clean_content
                        except (UnicodeDecodeError, PermissionError, OSError):
                            # Add note about unreadable file
                            note_elem = ET.SubElement(file_elem, 'note')
                            note_elem.text = "Content could not be read"
                    else:
                        # Add note about why content was skipped
                        note_elem = ET.SubElement(file_elem, 'note')
                        if file_path.stat().st_size &gt; self.max_file_size:
                            note_elem.text = f"File too large ({file_path.stat().st_size} bytes)"
                        else:
                            note_elem.text = "Binary file - content skipped"
                except (OSError, PermissionError) as e:
                    # Add entry for inaccessible file
                    file_elem = ET.SubElement(files_elem, 'file')
                    file_elem.set('name', file_path.name)
                    file_elem.set('path', str(file_path))
                    file_elem.set('type', 'inaccessible')
                    note_elem = ET.SubElement(file_elem, 'note')
                    note_elem.text = f"Access denied: {str(e)}"
        # Write XML with pretty formatting
        xml_str = ET.tostring(root, encoding='unicode')
        dom = minidom.parseString(xml_str)
        pretty_xml = dom.toprettyxml(indent='  ')
        # Remove empty lines from pretty printing
        lines = [line for line in pretty_xml.split('\n') if line.strip()]
        final_xml = '\n'.join(lines)
        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(final_xml)
        return output_path</content>
    </file>
    <file name="cli.py" path="/Users/geoanima/GitHub/codebase2xml/src/codebase2xml/cli.py" type="python" size="5118" modified="2025-06-30T18:07:01.182814" created="2025-06-30T18:45:50.351095" permissions="644" lines="159">
      <content>"""Command-line interface for codebase2xml."""
import argparse
import sys
from pathlib import Path
from typing import List, Optional
from .core import CodebaseArchiver
def parse_ignore_patterns(patterns_str: str) -&gt; List[str]:
    """Parse comma-separated ignore patterns."""
    if not patterns_str:
        return []
    return [pattern.strip() for pattern in patterns_str.split(',') if pattern.strip()]
def format_size(size_bytes: int) -&gt; str:
    """Format file size in human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes &lt; 1024:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024
    return f"{size_bytes:.1f} TB"
def main():
    """Main entry point for the codebase2xml CLI."""
    parser = argparse.ArgumentParser(
        prog='codebase2xml',
        description='Transform any codebase directory into a comprehensive XML archive',
        epilog='Example: codebase2xml /path/to/project --output project_archive.xml'
    )
    # Positional argument
    parser.add_argument(
        'codebase_path',
        type=str,
        help='Path to the codebase directory to archive'
    )
    # Optional arguments
    parser.add_argument(
        '--output', '-o',
        type=str,
        help='Output XML file path (default: generated in codebase directory)'
    )
    parser.add_argument(
        '--ignore', '-i',
        type=str,
        default='',
        help='Comma-separated list of patterns to ignore (e.g., "*.log,temp,*.tmp")'
    )
    parser.add_argument(
        '--max-size', '-s',
        type=int,
        default=10 * 1024 * 1024,  # 10MB
        help='Maximum file size to include content for (bytes, default: 10MB)'
    )
    parser.add_argument(
        '--include-binary', '-b',
        action='store_true',
        help='Include binary file content (not recommended for large files)'
    )
    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress progress output'
    )
    parser.add_argument(
        '--version', '-v',
        action='version',
        version='%(prog)s 1.0.0'
    )
    args = parser.parse_args()
    # Validate inputs
    codebase_path = Path(args.codebase_path).resolve()
    if not codebase_path.exists():
        print(f"‚ùå Error: Codebase path does not exist: {codebase_path}", file=sys.stderr)
        sys.exit(1)
    if not codebase_path.is_dir():
        print(f"‚ùå Error: Path is not a directory: {codebase_path}", file=sys.stderr)
        sys.exit(1)
    # Parse output path
    output_path = None
    if args.output:
        output_path = Path(args.output).resolve()
        # Ensure parent directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)
    # Parse ignore patterns
    ignore_patterns = parse_ignore_patterns(args.ignore)
    try:
        if not args.quiet:
            print(f"üîç Analyzing codebase: {codebase_path}")
            if ignore_patterns:
                print(f"   Ignoring patterns: {', '.join(ignore_patterns)}")
            print(f"   Max file size: {format_size(args.max_size)}")
            print(f"   Include binary: {'Yes' if args.include_binary else 'No'}")
            print()
        # Create archiver
        archiver = CodebaseArchiver(
            ignore_patterns=ignore_patterns,
            max_file_size=args.max_size,
            include_binary=args.include_binary
        )
        # Generate archive
        if not args.quiet:
            print("üì¶ Generating XML archive...")
        result_path = archiver.archive_codebase(codebase_path, output_path)
        if not args.quiet:
            # Show results
            archive_size = result_path.stat().st_size
            print(f"\n‚úÖ Archive created successfully!")
            print(f"   Output file: {result_path}")
            print(f"   Archive size: {format_size(archive_size)}")
            print(f"\nüìä Archive contains:")
            # Quick stats from the archiver's last run
            print(f"   üìÅ Directories: {archiver._extract_metadata(codebase_path)['total_directories']}")
            print(f"   üìÑ Files: {archiver._extract_metadata(codebase_path)['total_files']}")
            print(f"   üíæ Total size: {format_size(archiver._extract_metadata(codebase_path)['total_size'])}")
        else:
            # Just print the output path for scripts
            print(str(result_path))
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Archive generation cancelled by user.", file=sys.stderr)
        sys.exit(130)
    except PermissionError as e:
        print(f"‚ùå Permission denied: {e}", file=sys.stderr)
        sys.exit(1)
    except OSError as e:
        print(f"‚ùå System error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}", file=sys.stderr)
        if not args.quiet:
            import traceback
            traceback.print_exc()
        sys.exit(1)
if __name__ == '__main__':
    main()</content>
    </file>
    <file name="__main__.py" path="/Users/geoanima/GitHub/codebase2xml/src/codebase2xml/__main__.py" type="python" size="130" modified="2025-06-30T18:07:05.975920" created="2025-06-30T18:41:42.282521" permissions="644" lines="6">
      <content>"""Allow running codebase2xml as a module: python -m codebase2xml"""
from .cli import main
if __name__ == '__main__':
    main()</content>
    </file>
  </files>
</codebase>
